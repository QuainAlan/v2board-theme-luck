var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
import { k as defineComponent, $ as createElementBlock, U as openBlock, a0 as createBaseVNode, r as ref, R as createBlock, W as createVNode, V as withCtx, Q as renderList, L as normalizeClass, a3 as createCommentVNode, a4 as resolveDynamicComponent, a2 as toDisplayString, N as unref, I as normalizeStyle, F as Fragment, A as TransitionGroup, T as Teleport, M as createApp, c as computed, w as watch, o as onMounted, E as onUnmounted } from "./DM1yaN1X.js";
import { N as NIcon } from "./BEq_qS6Y.js";
import { _ as _export_sfc } from "./1tPrXgE0.js";
const _hoisted_1$8 = {
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  viewBox: "0 0 512 512"
};
const _hoisted_2$7 = /* @__PURE__ */ createBaseVNode(
  "path",
  {
    d: "M448 256c0-106-86-192-192-192S64 150 64 256s86 192 192 192s192-86 192-192z",
    fill: "none",
    stroke: "currentColor",
    "stroke-miterlimit": "10",
    "stroke-width": "32"
  },
  null,
  -1
  /* HOISTED */
);
const _hoisted_3$7 = /* @__PURE__ */ createBaseVNode(
  "path",
  {
    d: "M250.26 166.05L256 288l5.73-121.95a5.74 5.74 0 0 0-5.79-6h0a5.74 5.74 0 0 0-5.68 6z",
    fill: "none",
    stroke: "currentColor",
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    "stroke-width": "32"
  },
  null,
  -1
  /* HOISTED */
);
const _hoisted_4$7 = /* @__PURE__ */ createBaseVNode(
  "path",
  {
    d: "M256 367.91a20 20 0 1 1 20-20a20 20 0 0 1-20 20z",
    fill: "currentColor"
  },
  null,
  -1
  /* HOISTED */
);
const _hoisted_5$3 = [_hoisted_2$7, _hoisted_3$7, _hoisted_4$7];
const AlertCircleOutline = defineComponent({
  name: "AlertCircleOutline",
  render: function render(_ctx, _cache) {
    return openBlock(), createElementBlock("svg", _hoisted_1$8, _hoisted_5$3);
  }
});
const _hoisted_1$7 = {
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  viewBox: "0 0 512 512"
};
const _hoisted_2$6 = /* @__PURE__ */ createBaseVNode(
  "path",
  {
    d: "M448 256c0-106-86-192-192-192S64 150 64 256s86 192 192 192s192-86 192-192z",
    fill: "none",
    stroke: "currentColor",
    "stroke-miterlimit": "10",
    "stroke-width": "32"
  },
  null,
  -1
  /* HOISTED */
);
const _hoisted_3$6 = /* @__PURE__ */ createBaseVNode(
  "path",
  {
    fill: "none",
    stroke: "currentColor",
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    "stroke-width": "32",
    d: "M352 176L217.6 336L160 272"
  },
  null,
  -1
  /* HOISTED */
);
const _hoisted_4$6 = [_hoisted_2$6, _hoisted_3$6];
const CheckmarkCircleOutline = defineComponent({
  name: "CheckmarkCircleOutline",
  render: function render2(_ctx, _cache) {
    return openBlock(), createElementBlock("svg", _hoisted_1$7, _hoisted_4$6);
  }
});
const _hoisted_1$6 = {
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  viewBox: "0 0 512 512"
};
const _hoisted_2$5 = /* @__PURE__ */ createBaseVNode(
  "path",
  {
    fill: "none",
    stroke: "currentColor",
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    "stroke-width": "32",
    d: "M368 368L144 144"
  },
  null,
  -1
  /* HOISTED */
);
const _hoisted_3$5 = /* @__PURE__ */ createBaseVNode(
  "path",
  {
    fill: "none",
    stroke: "currentColor",
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    "stroke-width": "32",
    d: "M368 144L144 368"
  },
  null,
  -1
  /* HOISTED */
);
const _hoisted_4$5 = [_hoisted_2$5, _hoisted_3$5];
const CloseOutline = defineComponent({
  name: "CloseOutline",
  render: function render3(_ctx, _cache) {
    return openBlock(), createElementBlock("svg", _hoisted_1$6, _hoisted_4$5);
  }
});
const _hoisted_1$5 = {
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  viewBox: "0 0 512 512"
};
const _hoisted_2$4 = /* @__PURE__ */ createBaseVNode(
  "path",
  {
    d: "M248 64C146.39 64 64 146.39 64 248s82.39 184 184 184s184-82.39 184-184S349.61 64 248 64z",
    fill: "none",
    stroke: "currentColor",
    "stroke-miterlimit": "10",
    "stroke-width": "32"
  },
  null,
  -1
  /* HOISTED */
);
const _hoisted_3$4 = /* @__PURE__ */ createBaseVNode(
  "path",
  {
    fill: "none",
    stroke: "currentColor",
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    "stroke-width": "32",
    d: "M220 220h32v116"
  },
  null,
  -1
  /* HOISTED */
);
const _hoisted_4$4 = /* @__PURE__ */ createBaseVNode(
  "path",
  {
    fill: "none",
    stroke: "currentColor",
    "stroke-linecap": "round",
    "stroke-miterlimit": "10",
    "stroke-width": "32",
    d: "M208 340h88"
  },
  null,
  -1
  /* HOISTED */
);
const _hoisted_5$2 = /* @__PURE__ */ createBaseVNode(
  "path",
  {
    d: "M248 130a26 26 0 1 0 26 26a26 26 0 0 0-26-26z",
    fill: "currentColor"
  },
  null,
  -1
  /* HOISTED */
);
const _hoisted_6 = [_hoisted_2$4, _hoisted_3$4, _hoisted_4$4, _hoisted_5$2];
const InformationCircleOutline = defineComponent({
  name: "InformationCircleOutline",
  render: function render4(_ctx, _cache) {
    return openBlock(), createElementBlock("svg", _hoisted_1$5, _hoisted_6);
  }
});
const _hoisted_1$4 = {
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  viewBox: "0 0 512 512"
};
const _hoisted_2$3 = /* @__PURE__ */ createBaseVNode(
  "path",
  {
    d: "M336 208v-95a80 80 0 0 0-160 0v95",
    fill: "none",
    stroke: "currentColor",
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    "stroke-width": "32"
  },
  null,
  -1
  /* HOISTED */
);
const _hoisted_3$3 = /* @__PURE__ */ createBaseVNode(
  "rect",
  {
    x: "96",
    y: "208",
    width: "320",
    height: "272",
    rx: "48",
    ry: "48",
    fill: "none",
    stroke: "currentColor",
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    "stroke-width": "32"
  },
  null,
  -1
  /* HOISTED */
);
const _hoisted_4$3 = [_hoisted_2$3, _hoisted_3$3];
const LockClosedOutline = defineComponent({
  name: "LockClosedOutline",
  render: function render5(_ctx, _cache) {
    return openBlock(), createElementBlock("svg", _hoisted_1$4, _hoisted_4$3);
  }
});
const _hoisted_1$3 = {
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  viewBox: "0 0 512 512"
};
const _hoisted_2$2 = /* @__PURE__ */ createBaseVNode(
  "rect",
  {
    x: "48",
    y: "96",
    width: "416",
    height: "320",
    rx: "40",
    ry: "40",
    fill: "none",
    stroke: "currentColor",
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    "stroke-width": "32"
  },
  null,
  -1
  /* HOISTED */
);
const _hoisted_3$2 = /* @__PURE__ */ createBaseVNode(
  "path",
  {
    fill: "none",
    stroke: "currentColor",
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    "stroke-width": "32",
    d: "M112 160l144 112l144-112"
  },
  null,
  -1
  /* HOISTED */
);
const _hoisted_4$2 = [_hoisted_2$2, _hoisted_3$2];
const MailOutline = defineComponent({
  name: "MailOutline",
  render: function render6(_ctx, _cache) {
    return openBlock(), createElementBlock("svg", _hoisted_1$3, _hoisted_4$2);
  }
});
const _hoisted_1$2 = {
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  viewBox: "0 0 512 512"
};
const _hoisted_2$1 = /* @__PURE__ */ createBaseVNode(
  "path",
  {
    d: "M85.57 446.25h340.86a32 32 0 0 0 28.17-47.17L284.18 82.58c-12.09-22.44-44.27-22.44-56.36 0L57.4 399.08a32 32 0 0 0 28.17 47.17z",
    fill: "none",
    stroke: "currentColor",
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    "stroke-width": "32"
  },
  null,
  -1
  /* HOISTED */
);
const _hoisted_3$1 = /* @__PURE__ */ createBaseVNode(
  "path",
  {
    d: "M250.26 195.39l5.74 122l5.73-121.95a5.74 5.74 0 0 0-5.79-6h0a5.74 5.74 0 0 0-5.68 5.95z",
    fill: "none",
    stroke: "currentColor",
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    "stroke-width": "32"
  },
  null,
  -1
  /* HOISTED */
);
const _hoisted_4$1 = /* @__PURE__ */ createBaseVNode(
  "path",
  {
    d: "M256 397.25a20 20 0 1 1 20-20a20 20 0 0 1-20 20z",
    fill: "currentColor"
  },
  null,
  -1
  /* HOISTED */
);
const _hoisted_5$1 = [_hoisted_2$1, _hoisted_3$1, _hoisted_4$1];
const WarningOutline = defineComponent({
  name: "WarningOutline",
  render: function render7(_ctx, _cache) {
    return openBlock(), createElementBlock("svg", _hoisted_1$2, _hoisted_5$1);
  }
});
const _hoisted_1$1 = { class: "message-icon" };
const _hoisted_2 = { class: "message-content" };
const _hoisted_3 = {
  key: 0,
  class: "message-title"
};
const _hoisted_4 = { class: "message-text" };
const _hoisted_5 = ["onClick"];
const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  __name: "CustomMessage",
  setup(__props, { expose: __expose }) {
    const messages = ref([]);
    const getIcon = (type) => {
      const iconMap = {
        success: CheckmarkCircleOutline,
        error: AlertCircleOutline,
        warning: WarningOutline,
        info: InformationCircleOutline
      };
      return iconMap[type] || InformationCircleOutline;
    };
    const generateId = () => {
      return Date.now().toString(36) + Math.random().toString(36).substr(2);
    };
    const addMessage = (options) => {
      const message = {
        id: generateId(),
        type: options.type || "info",
        title: options.title,
        content: options.content,
        duration: options.duration ?? 4e3,
        closable: options.closable ?? true
      };
      messages.value.push(message);
      if (message.duration > 0) {
        setTimeout(() => {
          removeMessage(message.id);
        }, message.duration);
      }
      return message.id;
    };
    const removeMessage = (id) => {
      const index = messages.value.findIndex((msg) => msg.id === id);
      if (index > -1) {
        messages.value.splice(index, 1);
      }
    };
    const clear = () => {
      messages.value = [];
    };
    __expose({
      success: (content, options) => addMessage({ ...options, type: "success", content }),
      error: (content, options) => addMessage({ ...options, type: "error", content }),
      warning: (content, options) => addMessage({ ...options, type: "warning", content }),
      info: (content, options) => addMessage({ ...options, type: "info", content }),
      addMessage,
      removeMessage,
      clear
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(Teleport, { to: "body" }, [
        createVNode(TransitionGroup, {
          name: "message",
          tag: "div",
          class: "custom-message-container"
        }, {
          default: withCtx(() => [
            (openBlock(true), createElementBlock(Fragment, null, renderList(messages.value, (msg) => {
              return openBlock(), createElementBlock("div", {
                key: msg.id,
                class: normalizeClass([
                  "custom-message",
                  `custom-message--${msg.type}`,
                  { "custom-message--closable": msg.closable }
                ])
              }, [
                createBaseVNode("div", _hoisted_1$1, [
                  (openBlock(), createBlock(resolveDynamicComponent(getIcon(msg.type))))
                ]),
                createBaseVNode("div", _hoisted_2, [
                  msg.title ? (openBlock(), createElementBlock("div", _hoisted_3, toDisplayString(msg.title), 1)) : createCommentVNode("", true),
                  createBaseVNode("div", _hoisted_4, toDisplayString(msg.content), 1)
                ]),
                msg.closable ? (openBlock(), createElementBlock("button", {
                  key: 0,
                  class: "message-close",
                  onClick: ($event) => removeMessage(msg.id)
                }, [
                  createVNode(unref(NIcon), { component: unref(CloseOutline) }, null, 8, ["component"])
                ], 8, _hoisted_5)) : createCommentVNode("", true),
                msg.duration > 0 ? (openBlock(), createElementBlock("div", {
                  key: 1,
                  class: "message-progress",
                  style: normalizeStyle({ animationDuration: msg.duration + "ms" })
                }, null, 4)) : createCommentVNode("", true)
              ], 2);
            }), 128))
          ]),
          _: 1
        })
      ]);
    };
  }
});
const CustomMessage = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["__scopeId", "data-v-a328c8ec"]]);
class MessageService {
  constructor() {
    __publicField(this, "app", null);
    __publicField(this, "instance", null);
    __publicField(this, "container", null);
  }
  init() {
    if (this.instance) return;
    this.container = document.createElement("div");
    this.container.id = "custom-message-container";
    document.body.appendChild(this.container);
    this.app = createApp(CustomMessage);
    this.instance = this.app.mount(this.container);
  }
  ensureInit() {
    if (!this.instance) {
      this.init();
    }
  }
  success(content, options) {
    this.ensureInit();
    return this.instance.success(content, options);
  }
  error(content, options) {
    this.ensureInit();
    return this.instance.error(content, options);
  }
  warning(content, options) {
    this.ensureInit();
    return this.instance.warning(content, options);
  }
  info(content, options) {
    this.ensureInit();
    return this.instance.info(content, options);
  }
  // 登录相关的专用消息
  loginSuccess() {
    return this.success("登录成功", {
      title: "欢迎回来",
      duration: 2e3
    });
  }
  loginError(message) {
    let title = "登录失败";
    let content = message;
    if (message.includes("密码错误") || message.includes("Incorrect email or password")) {
      title = "登录失败";
      content = "邮箱或密码错误，请检查后重试";
    } else if (message.includes("too many password errors") || message.includes("密码错误次数过多")) {
      title = "账户暂时锁定";
      content = "密码错误次数过多，请稍后再试";
    } else if (message.includes("suspended") || message.includes("账户被封禁")) {
      title = "账户已被封禁";
      content = "您的账户已被管理员封禁，请联系客服";
    } else if (message.includes("网络") || message.includes("连接")) {
      title = "网络连接失败";
      content = "请检查网络连接后重试";
    }
    return this.error(content, {
      title,
      duration: 5e3
    });
  }
  // 注册相关的专用消息
  registerSuccess() {
    return this.success("注册成功，正在为您登录...", {
      title: "欢迎加入",
      duration: 2e3
    });
  }
  registerError(message) {
    let title = "注册失败";
    let content = message;
    if (message.includes("Email already exists") || message.includes("邮箱已存在")) {
      title = "邮箱已被使用";
      content = "该邮箱已被注册，请使用其他邮箱或直接登录";
    } else if (message.includes("Invalid invitation code") || message.includes("邀请码无效")) {
      title = "邀请码无效";
      content = "请检查邀请码是否正确或联系邀请人";
    } else if (message.includes("Register frequently") || message.includes("注册频繁")) {
      title = "注册过于频繁";
      content = "请稍后再试";
    } else if (message.includes("Registration has closed") || message.includes("注册已关闭")) {
      title = "暂停注册";
      content = "当前暂停新用户注册，请联系管理员";
    }
    return this.error(content, {
      title,
      duration: 5e3
    });
  }
  // 通用网络错误
  networkError() {
    return this.error("网络连接失败，请检查网络后重试", {
      title: "网络错误",
      duration: 4e3
    });
  }
  // 服务器错误
  serverError() {
    return this.error("服务器暂时无法响应，请稍后重试", {
      title: "服务器错误",
      duration: 4e3
    });
  }
  // 清空所有消息
  clear() {
    if (this.instance) {
      this.instance.clear();
    }
  }
  // 销毁实例
  destroy() {
    if (this.app) {
      this.app.unmount();
      this.app = null;
      this.instance = null;
    }
    if (this.container && this.container.parentNode) {
      this.container.parentNode.removeChild(this.container);
      this.container = null;
    }
  }
}
const customMessage = new MessageService();
const _hoisted_1 = {
  key: 0,
  class: "captcha-widget"
};
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "CaptchaWidget",
  props: {
    modelValue: {},
    page: { default: "login" }
  },
  emits: ["update:modelValue", "verified", "expired", "error"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const captchaConfig = computed(() => {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i;
      const config = (_b = (_a = window.V2BOARD_CONFIG) == null ? void 0 : _a.LOGIN_LOGO) == null ? void 0 : _b.CAPTCHA;
      const service = (config == null ? void 0 : config.SERVICE) || "none";
      const pageKey = props.page.toUpperCase();
      const pageEnabled = ((_c = config == null ? void 0 : config.PAGES) == null ? void 0 : _c[pageKey]) || false;
      return {
        service,
        pageEnabled,
        turnstile: {
          enabled: service === "turnstile" && pageEnabled,
          siteKey: ((_d = config == null ? void 0 : config.TURNSTILE) == null ? void 0 : _d.SITE_KEY) || "",
          theme: ((_e = config == null ? void 0 : config.TURNSTILE) == null ? void 0 : _e.THEME) || "auto",
          size: ((_f = config == null ? void 0 : config.TURNSTILE) == null ? void 0 : _f.SIZE) || "flexible"
        },
        recaptcha: {
          enabled: service === "recaptcha" && pageEnabled,
          siteKey: ((_g = config == null ? void 0 : config.RECAPTCHA) == null ? void 0 : _g.SITE_KEY) || "",
          theme: ((_h = config == null ? void 0 : config.RECAPTCHA) == null ? void 0 : _h.THEME) || "light",
          size: ((_i = config == null ? void 0 : config.RECAPTCHA) == null ? void 0 : _i.SIZE) || "normal"
        }
      };
    });
    const hasCaptcha = computed(() => {
      return captchaConfig.value.turnstile.enabled || captchaConfig.value.recaptcha.enabled;
    });
    const turnstileRef = ref();
    const recaptchaRef = ref();
    let turnstileWidgetId = null;
    let recaptchaWidgetId = null;
    const currentToken = ref("");
    const currentType = ref("");
    watch(currentToken, (newToken) => {
      emit("update:modelValue", newToken);
      if (newToken) {
        emit("verified", newToken, currentType.value);
      }
    });
    const loadTurnstileScript = () => {
      return new Promise((resolve, reject) => {
        if (window.turnstile) {
          resolve();
          return;
        }
        const script = document.createElement("script");
        script.src = "https://challenges.cloudflare.com/turnstile/v0/api.js";
        script.async = true;
        script.defer = true;
        script.onload = () => resolve();
        script.onerror = () => reject(new Error("Failed to load Turnstile script"));
        document.head.appendChild(script);
      });
    };
    const loadRecaptchaScript = () => {
      return new Promise((resolve, reject) => {
        if (window.grecaptcha) {
          resolve();
          return;
        }
        const script = document.createElement("script");
        script.src = "https://www.google.com/recaptcha/api.js";
        script.async = true;
        script.defer = true;
        script.onload = () => {
          window.grecaptcha.ready(() => resolve());
        };
        script.onerror = () => reject(new Error("Failed to load reCAPTCHA script"));
        document.head.appendChild(script);
      });
    };
    const initTurnstile = async () => {
      if (!turnstileRef.value || !captchaConfig.value.turnstile.siteKey) return;
      try {
        await loadTurnstileScript();
        turnstileWidgetId = window.turnstile.render(turnstileRef.value, {
          sitekey: captchaConfig.value.turnstile.siteKey,
          theme: captchaConfig.value.turnstile.theme,
          size: captchaConfig.value.turnstile.size,
          callback: (token) => {
            currentToken.value = token;
            currentType.value = "turnstile";
          },
          "expired-callback": () => {
            currentToken.value = "";
            currentType.value = "";
            emit("expired");
          },
          "error-callback": (error) => {
            currentToken.value = "";
            currentType.value = "";
            emit("error", error);
          }
        });
      } catch (error) {
        console.error("Failed to initialize Turnstile:", error);
        emit("error", "Failed to load Turnstile");
      }
    };
    const initRecaptcha = async () => {
      if (!recaptchaRef.value || !captchaConfig.value.recaptcha.siteKey) return;
      try {
        await loadRecaptchaScript();
        recaptchaWidgetId = window.grecaptcha.render(recaptchaRef.value, {
          sitekey: captchaConfig.value.recaptcha.siteKey,
          theme: captchaConfig.value.recaptcha.theme,
          size: captchaConfig.value.recaptcha.size,
          callback: (token) => {
            currentToken.value = token;
            currentType.value = "recaptcha";
          },
          "expired-callback": () => {
            currentToken.value = "";
            currentType.value = "";
            emit("expired");
          },
          "error-callback": () => {
            currentToken.value = "";
            currentType.value = "";
            emit("error", "reCAPTCHA verification failed");
          }
        });
      } catch (error) {
        console.error("Failed to initialize reCAPTCHA:", error);
        emit("error", "Failed to load reCAPTCHA");
      }
    };
    const reset = () => {
      currentToken.value = "";
      currentType.value = "";
      if (captchaConfig.value.turnstile.enabled && turnstileWidgetId && window.turnstile) {
        window.turnstile.reset(turnstileWidgetId);
      }
      if (captchaConfig.value.recaptcha.enabled && recaptchaWidgetId !== null && window.grecaptcha) {
        window.grecaptcha.reset(recaptchaWidgetId);
      }
    };
    const getToken = () => {
      return currentToken.value;
    };
    const getType = () => {
      return currentType.value;
    };
    __expose({
      reset,
      getToken,
      getType
    });
    onMounted(() => {
      if (captchaConfig.value.turnstile.enabled) {
        initTurnstile();
      }
      if (captchaConfig.value.recaptcha.enabled) {
        initRecaptcha();
      }
    });
    onUnmounted(() => {
      if (turnstileWidgetId && window.turnstile) {
        try {
          window.turnstile.remove(turnstileWidgetId);
        } catch (error) {
          console.warn("Failed to remove Turnstile widget:", error);
        }
      }
    });
    return (_ctx, _cache) => {
      return hasCaptcha.value ? (openBlock(), createElementBlock("div", _hoisted_1, [
        captchaConfig.value.turnstile.enabled ? (openBlock(), createElementBlock("div", {
          key: 0,
          ref_key: "turnstileRef",
          ref: turnstileRef,
          class: "turnstile-widget"
        }, null, 512)) : createCommentVNode("", true),
        captchaConfig.value.recaptcha.enabled ? (openBlock(), createElementBlock("div", {
          key: 1,
          ref_key: "recaptchaRef",
          ref: recaptchaRef,
          class: "recaptcha-widget"
        }, null, 512)) : createCommentVNode("", true)
      ])) : createCommentVNode("", true);
    };
  }
});
const CaptchaWidget = /* @__PURE__ */ _export_sfc(_sfc_main, [["__scopeId", "data-v-ecc224f8"]]);
export {
  CaptchaWidget as C,
  LockClosedOutline as L,
  MailOutline as M,
  customMessage as c
};
